<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<head>
  <title>Geoff's Sound Change Applier</title>
<style type="text/css">
pre {color: navy; background-color: white; border: dashed black 1px;
     padding: 4px}
tt { color: green; background-color: white; }
h3 { text-decoration: underline}
h2 { background-color: #ffffcc}
</style>
</head>

<body text="#000000" bgcolor="#ccffcc" link="#0000ff" vlink="#0000ff">

<h1>Geoff's Sound Change Applier</h1>

<a href="../index.html">Geoff's homepage</a> -&gt;
<a href="index.html">Artificial Languages</a> -&gt;
Sound Change Applier<p>

Last update: 31 August 2010 (version 0.8)<p>

<hr><h2>Contents</h2>

<ul>
  <li> <a href="#about">About SCA</a>
  <li> <a href="#rules">Rules and terminology</a>
  <li> <a href="#hlp">Higher-level processing</a>
  <li> <a href="#clopts">Command-line options</a>
  <li> <a href="#conv">Converting from older versions</a>
  <li> <a href="#sample">Sample rules</a>
</ul>

<a name="about"></a><hr><h2>About SCA</h2>

Geoff's Sound Change Applier, <b>SCA</b> hereafter, is a program which
applies rule-based transformations to strings of Unicode text. It is
written in <a href="http://www.python.org">Python</a> and uses
configuration files in <a href="http://yaml.org/">YAML</a>, so you'll
need to install Python (SCA is known to work with version 2.6, but
probably won't with 3.x) and <a href="pyyaml.org">PyYAML</a> to be
able to use it.<p>

SCA was originally written as an aid for linguists and conlangers to
simulate the effects of the Neo-grammarian concept of sound-change and
is accordingly oriented towards this use, although it should be usable
for any similar non-linguistic task. You can, for example, very easily
write <a href="http://en.wikipedia.org/wiki/L-system">L-systems</a> in
it. It was originally based on <a
href="http://www.zompist.com/sounds.htm"> a C program written by Mark
Rosenfelder</a>, which is fine for what it does, but I needed
something more powerful for my porpoises, which frequently require one
word to be converted into several descendants simultaneously. I
recommend reading the documentation for his program anyway, since
although it works somewhat differently from mine, many of the
underlying concepts and principles are the same.<p>

For version 0.8, SCA has been completely redesigned and rewritten. It
is not completely compatible with earlier versions; a section in this
file explains what to do to convert .sc files which used to work.<p>

<h3>Getting SCA</h3>

All of the necessary files are stored in <a href="sca0.8.zip">this
file</a>:

<ul>
  <li> <b>SCAdefs.py SCAitem.py SCArule.py SCA.py SCApply.py</b>: The
       Python implementation.
  <li> <b>SCAchars.yaml SCAdirparams.yaml SCAparams.yaml</b>: The YAML
       configuration files. Don't edit these unless you are absolutely
       sure you have a good reason for doing so.
  <li> <b>SCAtest.py SCAtest.yaml</b>: a test suite. You can safely
       ignore this, but you're still welcome to add tests to it.
  <li> <b>sca.html</b>: a copy of this file, except that the local
       links won't work.
  <li> <b>spanish.sca</b>: sample file with very approximate sound
       changes from Latin to Spanish. It is most definitely <i>not</i>
       guaranteed to be authoritative!
  <li> <b>ipa.sca</b>: some definitions for use with IPA symbols.
<!--  <li> <b>sc-mode.el</b>: syntax highlighting mode for GNU Emacs.-->
</ul><p>

<h3>Licensing and re-use</h3>

I can't guarantee that SCA will be suitable for your requirements, but
if you use it and find it helpful, I'd love to know. I'd also be
interested to hear about any suggestions you have for future
improvements and any bugs which you may have found.<p>

You may do what you like with SCA, free of charge, including using its
code in something of your own; if you want to know how to do this, and
can't figure it out from the code, just ask me for the details. I only
ask that you credit me and link to this page if you use SCA for
anything you publish, whether software or output: share and enjoy,
don't steal credit for something you didn't create. Something like
"Output generated by <a
href="http://gesc19764.pwp.blueyonder.co.uk/sca.html">Geoff's SCA</a>"
will do fine.

<a name="rules"></a><hr><h2>Rules and terminology</h2>

SCA's behaviour is specified by a sequence of <b>rules</b>, which are
typically stored in one or more text files and executed with the
<b>SCApply.py</b> script. If you want to try the following examples
out for yourself, type the rule into a file, save the file as
"foo.sca", and run the script as follows:<p>

<pre>
python SCApply.py -q -cfoo &lt;WORD&gt;
</pre><p>

where <tt>WORD</tt> is the example word; it can actually be several
words, if you're feeling adventurous.<p>

<h3>Basic replacements</h3>

The most basic rule simply replaces all occurrences of one piece of
text with another, for example:<p>

<pre>* a x _   ! banana -> bxnxnx</pre><p>

This rule consists of five elements, which are separated by white
space:<p>

<ul>
  <li> A <b>dialect specifier</b>. Ignore this for now.
  <li> The text which needs to be changed. This is referred to as
       <tt>BEFORE</tt> hereafter.
  <li> What <tt>BEFORE</tt> should be changed to; this is
       <tt>AFTER</tt>.
  <li> The <b>environment</b>. This must contain an underscore; the
       text before this underscore is referred to as <tt>PRE</tt>, and
       the text after it is called <tt>POST</tt>. If both <tt>PRE</tt>
       and <tt>POST</tt> are empty, it means "everywhere".
  <li> A <b>comment</b>. This consists of the exclamation mark and
       everything which follows it, and is ignored. Comments in the
       example rules in this document show what the effect of the rule
       will be.
</ul><p>

Comments are optional; the other parts are mandatory. <tt>BEFORE</tt>
and <tt>AFTER</tt> are together known as the <b>change</b> (better,
perhaps, <b>transformation</b>, but that's longer to type).<p>

<tt>PRE</tt> and <tt>POST</tt> may be used to restrict the change to
occur before or after, or between, specific text; this models
<b>conditioned</b> sound-changes in historical linguistics:<p>

<pre>
* a x b_   ! banana -> bxnana
* a x _n   ! banana -> bxnxna
* a x n_n  ! banana -> banxna
</pre><p>

Note, however, the following:

<pre>* n x a_a   ! banana -> baxana</pre><p>

This does not give <tt>baxaxa</tt> - why? The answer is closely
related to the <b>banana problem</b>, which asks, "how many
occurrences of <tt>ana</tt> are there in <tt>banana</tt>? The problem
is that there are either one or two, depending on whether you count
overlapping occurrences or not. By default, SCA only considers
nonoverlapping occurrences, but you can append a <b>flag</b> to a rule
to make it consider overlapping ones as well:<p>

<pre>* n x a_a B  ! banana -> baxaxa</pre><p>

Anything which follows the environment is ocnsidered to be a
flag. Some other ones are <tt>F</tt> (for "first"), which performs the
replacement once only starting from the beginning, and <tt>L</tt> (for
"last"), which does the same from the end:<p>

<pre>
* a x _ F  ! banana -> bxnana
* a x _ L  ! banana -> bananx
</pre><p>

There is also <tt>R</tt>, which does the same as <tt>B</tt> but
starting from the end.<p>

NOTE: Use at most one of <tt>BRFL</tt>. The results of combining them
are not guaranteed.<p>

<h3>Quantifiers</h3>

SCA supports the regular expression metacharacters <tt>. ? + * |</tt>,
so you can write rules like:<p>

<pre>
* b|n x _  ! banana -> xaxaxa
* nc? x _  ! bananca -> baxaxa
* na* x _  ! bananaanta -> baxxxta
* na+ x _  ! bananaanta -> baxxnta
* b.n x _  ! bananabendy -> xanaxdy
</pre><p>

<tt>BEFORE</tt> in these rules means respectively:<p>

<ul>
  <li> <tt>b</tt> or <tt>n</tt>
  <li> <tt>n</tt>, optionally followed by a <tt>c</tt>
  <li> <tt>n</tt>, optionally followed by one or more <tt>a</tt>'s
  <li> <tt>n</tt>, followed by one or more <tt>a</tt>'s
  <li> <tt>b</tt>, followed by anything, followed by <tt>a</tt>
</ul><p>

Generally speaking, though, it's better to avoid such explicit regular
expressions in SCA; there are almost always better ways to specify
what you want.<p>

If you want to use a character with special meaning as itself, precede
it with a backslash; this includes the backslash character itself:<p>

<pre>
* \+ plus _ ! 3+3 -> 3plus3
* \\ /  _ ! path\to\file -> path/to/file
</pre><p>

<h3>Categories</h3>

Suppose you want to replace all vowels in a word with <tt>x</tt>. One
way to do this is with the first rule:<p>

<pre>* a x _</pre><p>

repeated five times, with <tt>a</tt> replaced successively by <tt>e i
o u</tt>. But this is clearly inefficient; a better rule is:<p>

<pre>* a|e|i|o|u x _</pre><p>

Still better, though, is to define a <b>category</b>:<p>

<pre>
vowel = aeiou
* &lt;vowel&gt; x _  ! facetious -> fxcxtxxxs
</pre><p>

The first line defines the category <tt>vowel</tt> to consist of the
letters <b>aeiou</b>; the second refers to it in <tt>BEFORE</tt>.<p>

A category is an ordered list, so if you have categories in both
<tt>BEFORE</tt> and <tt>AFTER</tt>, SCA will replace a character in
the first category with the corresponding one in the second:<p>

<pre>
ustop = ptc
vstop = bdg
* &lt;ustop&gt; &lt;vstop&gt; _  ! reaction -> reagdion
</pre><p>

You can also use categories in <tt>PRE</tt> and <tt>POST</tt>, so you
can model Welsh-style intervocalic lenition of voiceless stops
with:<p>

<pre>
vowel = aeiou
ustop = ptc
vstop = bdg
* &lt;ustop&gt; &lt;vstop&gt; &lt;vowel&gt;_&lt;vowel&gt;  ! tecos -> tegos
</pre><p>

A category name should really consist only of letters and digits, must
not start with a digit, and should not be all in
uppercase. (Personally, I'd disallow digits completely.)<p>

You can't use a category in <tt>AFTER</tt> to replace simple text in
<tt>BEFORE</tt>, because there is no meaningful way to decide which
value from the category to use, so you can't do this:<p>

<pre>* h F _ ! ERROR!</pre><p>

<h3>More about categories</h3>

A category name can also be a single uppercase character, in which
case the angle brackets are not needed to refer to it:<p>

<pre>
C = bcdfghjklmnpqrstvwxyz
V = aeiou
* C x V_V ! ambitious -> ambixious
</pre><p>

Categories can be extended, combined, and reduced in several ways. For
example, in definitions:<p>

<pre>
cat1 = abc def  ! cat1 = "abcdef"
cat2 = cat1 ghi ! cat2 = "abcdefghi"
cat3 = ca t1    ! cat3 = "cat1"
A    = abc Def  ! A    = "abcDef"
B    = xyz      ! B    = "xyz"
C    = A g h i  ! C    = "abcDefghi"
D    = jkl      ! not allowed; "D" has previously been used as a symbol.
E    = AB       ! E    = "AB"; don't do this either.
F    = A B      ! F    = "abcxyz"; this is the correct way to do it.
</pre><p>

And in references:<p>

<pre>
cat = abcdef
dog = ghijkl

&lt;cat&gt;         ! "abcdef", of course
&lt;^cat&gt;        ! Complementation; anything but "abcdef"
&lt;cat+ghi&gt;     ! Augmentation; "abcdefghi"
&lt;cat-ace&gt;     ! Subtraction; "bdf"
&lt;+ghi&gt;        ! One-off reference; "ghi"
&lt;-ghi&gt;        ! One-off complement; anything other than "ghi"
&lt;cat,dog&gt;     ! Combination; "abcdefghijkl"
&lt;cat,dog+xyz&gt; ! Combination; "abcdefghijklxyz"
&lt;cat,dog-aei&gt; ! Combination; "bcdfghjkl"
</pre>

It is better to use these for one-offs only and define separate
categories if you need to use them a lot.<p>

In general, a string of letters in a category reference will be
treated as the category definition if there is one, otherwise the
letters themselves. Note, however, that if all contiguous letters in a
reference are uppercase, they will be treated as categories; thus
<tt>&lt;AB&gt;</tt> is the same as <tt>&lt;A+B&gt;</tt>.<p>

SCA tries to be sensible when one category replaces another and there
are different numbers of characters in the two categories, or if there
are duplicate characters. If the category in <tt>BEFORE</tt> is
longer, the extra characters are deleted; if the one in <tt>AFTER</tt>
is longer, the extra charactres are simply ignored:<p>

<pre>
* &lt;+abcde&gt;  &lt;+xyz&gt;    _ ! debacle -> yxzl
* &lt;+abc&gt;    &lt;+vwxyz&gt;  _ ! debacle -> dewvxle
</pre><p>

Duplicates in <tt>AFTER</tt> should not be surprising; duplicates in
<tt>BEFORE</tt> ignore every occurrence except the first:<p>

<pre>
* &lt;+abcde&gt;  &lt;+xxyyz&gt;  _ ! debacle -> yzxxylz
* &lt;+abbcde&gt; &lt;+xxyyzz&gt; _ ! debacle -> zzxxylz
</pre><p>

It's legal to use quantifiers with categories, thus, to remove
sequences of <tt>x</tt> followed by one or more vowels, you'd do
this:<p>

<pre>* x&lt;vowel&gt;+ 0 _</pre><p>

Zeros in a category in <tt>AFTER</tt> will delete the corresponding
characters in <tt>BEFORE</tt>:

<pre>* &lt;+abcde&gt;  &lt;+x0y0z&gt;  _ ! debacle -> zxylz</pre><p>

Finally, note this rather silly situation:<p>

<pre>
T = ptk
V = aeiou
* &lt;TV&gt; &lt;VT&gt; _
</pre><p>

The rule is equivalent to:<p>

<pre>* &lt;+ptkaeiou&gt; &lt;aeiouptk&gt; _</pre><p>

which probably won't do what you want.

<h3>Features</h3>

Features are an alternative way of looking at category
replacements. They're an attempt to satisfy those who prefer the
lower-level sort of sound-change rule which looks like this:<p>

<pre>* [-voice] [+voice] V_V ! ata -> ada</pre>

A feature is defined as a pair of category-like definitions separated
by a pipe. The first part of the pair specifies the characters which
do not have the feature, and the second part specifies those which do,
so that the meaning is "adding the feature to each character in the
first part produces the corresponding character in the second
part". There must be the same number of characters in each part. For
example, <tt>voice</tt> could be defined as one of the following:<p>

<pre>
feature voice ustop ufric | vstop vfric
ptk f s h | b d g vz G
</pre><p>

Features can't be defined in terms of other features, but they can be
combined:<p>

<pre>
feature fric ustop vstop | ufric vfric ! define feature "fric"
[-voice,-fric] [+voice,+fric] V_V      ! kata -> kaza
</pre>

<h3>Indexes, positions, and zero</h3>

The following definitions are assumed hereafter.<p>

<pre>
T = ptk
D = bdg
F = fθx
N = mnŋ
V = aeiou
L = lr
stop = T D
</pre><p>

In a rule like:<p>

<pre>* F Th _ ! fotografy -> photography</pre><p>

SCA is clever enough to know that <tt>T</tt> and <tt>F</tt> are both
in the same position in their parts, so an <tt>F</tt> should be
replaced with a <tt>T</tt>. The reverse will also work, so:<p>

<pre>* Th F _ ! photography -> fotografy</pre><p>

However, this (hello, Sally Caves!) won't:

<pre>* F hT _ ! ERROR!</pre><p>

because there is nothing corresponding to the <tt>T</tt>. However, you
can do this instead:<p>

<pre>* F h<1T> _ ! fotografy -> hpotograhpy</pre><p>

Internally, <tt>BEFORE</tt> and <tt>AFTER</tt> are converted to a
sequence of <b>items</b>; a category makes up a single item, as does
any contiguous string of ordinary characters and regexp
metacharacters. In <tt>AFTER</tt> in this rule, <tt>&lt;1T&gt;</tt>
means "replace the first item in <tt>BEFORE</tt> with the
corresponding <tt>T</tt>"; this is called a <b>category mapping</b>.
Note that the angle brackets are mandatory here, regardless of the
name of the category.<p>

Digits can be used in <tt>AFTER</tt> to refer to items in
<tt>BEFORE</tt>, so you can make two characters change places
(<b>metathesis</b>) with:<p>

<pre>* VL 21 <stop>_<stop> ! tort -> trot</pre><p>

The digit <tt>0</tt> (zero) has the special meaning of "nothing". So
you can get rid of characters you don't like by replacing them with
zero:<p>

<pre>* F 0 _ ! fusty -> uty</pre><p>

A more complicated example, which deletes anything between an
<tt>N</tt> and a <tt>T</tt>, is:<p>

<pre>* . 0 N_T ! nutmeg -> ntmg</pre><p>

This can also be written:<p>

<pre>* N.T 13 _ ! nutmeg -> ntmg</pre><p>

Our problematic rule earlier can also be fixed with a zero to pad the
rule out, although this is not recommended:<p>

<pre>* 0F hT _ ! fotografy -> hpotograhpy</pre><p>

In general, if you have several ways of expressing the same rule, the
choice depends on how you view the rule. For example, both the
following do the same thing:<p>

<pre>
* etymology entomology _
* ty        nto       e_mology
</pre><p>

but one views the change as replacing one complete string with another,
while the other considers only the parts which actually change.<p>

If you have zero on its own in <tt>BEFORE</tt>, you can create
characters out of nothing (<b>epenthesis</b>):<p>

<pre>* 0 p m_r ! amra -> ampra</pre><p>

This is more useful with <a href="blend">blends</a>, with which it can
be generalised.

<h3>Strings and lists</h3>

A <b>string</b> is a sequence of characters which you would like to
use more than once. For example, if you want to censor the string
'xenu' differently in different contexts, you can do this:<p>

<pre>
string foo xenu     ! define string 'foo'
* $foo$ xxxx _\.net ! www.xenu.net -> www.xxxx.net
* $foo$ yyyy _      ! "his name was xenu" -> "his name was yyyy"
</pre><p>

A <b>list</b> is like a category, except that it is made up of
strings rather than single characters:<p>

<pre>
list dips   ei,ai,oi,eu,au,ou  ! define list 'dips'
list single i,e,e,u,o,o        ! define list 'single'
* ~dips~ ~single~ _            ! reitainous -> ritenos
</pre><p>

You can interpolate strings in lists, and replace lists and categories
with each other:<p>

<pre>
list dips   ei,ai,oi,eu,au,ou
foo = uvwxyz
* ~dips~ &lt;foo&gt; _ ! daireitous -> dvrutzs
* &lt;foo&gt; ~dips~ _ ! vexedly -> aieoiedlau
</pre><p>

Note, however, that this won't do what you might expect:<p>

<pre>
list dips   ei,ai,oi,eu,au,ou
* ~dips~ <+ieeoou> _ ! daireitous -> derits
</pre><p>

This is because <tt>&lt;ieeoou&gt;</tt> is a category, not a list, and
it ends up as <tt>ieou</tt>.

<h3>Referring to BEFORE, PRE, and POST</h3>

Suppose you want to reduce a sequence of two identical characters to
one. Within SCA, the way to do this is to regard it as removing a
character if it appears after itself, so we need a way of specifing
that <tt>PRE</tt> is to be equal to <tt>BEFORE</tt>. The percent sign
is interpreted in SCA as meaning <tt>BEFORE</tt> when it in
<tt>PRE</tt> or <tt>POST</tt>:<p>

<pre>
* a 0 %_ ! bazaar -> bazar
* a 0 _% ! bazaar -> bazar, exactly the same
</pre><p>

This will also work with strings and, more usefully, lists:<p>

<pre>
string foo xyz
list dips ei,ai,oi,eu,au,ou
* $foo$  0 %_ ! xyzxyz -> xyz
* ~dips~ 0 %_ ! raiain -> rain
</pre><p>

The signs <tt>&lt;</tt> and <tt>&gt;</tt> can be used by themselves in
<tt>AFTER</tt> to represent <tt>PRE</tt> and <tt>POST</tt>
respectively; this models <b>complete assimilation</b>:<p>

<pre>
* N &gt; _D ! android -> addroid
* D &lt; N_ ! android -> annroid
</pre><p>

And you can also use <tt>&lt;</tt> in <tt>POST</tt>; thus to delete
something which appears between two identical vowels:<p>

<pre>* N 0 V_&lt; ! canal -> caal</pre><p>

You can have other things in <tt>PRE</tt> and <tt>POST</tt> alongside
the percent sign, although this is not yet guaranteed to work:<p>

<pre>* a 0 _n% ! banana -> bnna</pre><p>

<h3>Anchors</h3>

The hash character in <tt>PRE</tt> means "the beginning of the text",
and in <tt>POST</tt> it means "the end of the text". So you can remove
a single final vowel with:<p>

<pre>* V 0 _# ! racine -> racin</pre><p>

or several with:<p>

<pre>* V+ 0 _# ! superbee -> superb</pre><p>

Similarly, to put an <tt>h</tt> before an initial vowel:<p>

<pre>* 0 h #_V ! umour -> humour</pre><p>

Quite often, you need to indicate "initially or after a consonant";
this works as you might expect:<p>

<pre>* h 0 #|&lt;cons&gt;_ ! heather -> eater</pre><p>

<a name="blend"></a><h3>Blends</h3>

Blends are probably the trickiest part of SCA to understand, which is
why they have been left to last.<p>

A blend is a special type of category replacement in which the
category and the index of the replacement character in the category
come from different places, rather than taking them both from
<tt>AFTER</tt>. It is specified as <tt>{cat:pos}</tt>, where
<b>cat</b> specifies the category and <tt>pos</tt> the position. For
example, in:<p>

<pre>* N {1:>1} _T ! anpa -> ampa</pre><p>

the category comes from <tt>BEFORE</tt> and the position from
<tt>POST</tt>; the effect is that the item in <tt>AFTER</tt> remains a
nasal, but shifts position. In linguistic terms, this is <b>regressive
assimilation</b> of the nasal to the following stop. If you switch the
two parts of the blend, like this:<p>

<pre>* N {>1:1} _T ! anpa -> atpa</pre><p>

the position stays the same, but the category changes instead. This is
almost the same as this normal category replacement:<p>

<pre>* N T _T ! anpa -> atpa</pre><p>

except that the replacement category comes from <tt>POST</tt> rather
than being explicitly specified.<p>

<tt>1</tt> means "the first item in <tt>BEFORE</tt>", and <tt>>1</tt>
means "the first item in <tt>POST</tt>". Similarly, <tt>&lt;1</tt>
means "the first item in <tt>PRE</tt>", and can be used to indicate
<b>progressive</b> assimilation:<p>

<pre>
* N {1:&lt;1} _T ! anpa -> anta
* N {&lt;1:1} _T ! anpa -> anma
</pre><p>

The indexes - <tt>1</tt> in all of these examples - can be omitted, in
which case the item from which the category or position is taken is
the corresponding item in the appropriate part. So, these four
examples could also be written:<p>

<pre>
* NT {:2}2 _ ! anpa -> ampa
* NT {2:}2 _ ! anpa -> atpa
* NT 1{:1} _ ! anpa -> anta
* NT 1{1:} _ ! anpa -> anma
</pre><p>

where the unspecified category indexes are taken to be 1 in the first
two and 2 in the others.<p>

Blends can also model <b>epenthesis</b>, with zero in <tt>BEFORE</tt>;
you need either to have both <tt>PRE</tt> and <tt>POST</tt> in the
blend:<p>

<pre>
* 0 {&gt;:&lt;} N_T ! amta -> ampta
* 0 {&lt;:&gt;} N_T ! amta -> amnta
</pre>

or an explicit category in the category part:<p>

<pre>
* 0 {T:&lt;} N_L ! anra -> antra
* 0 {T:&gt;} L_N ! arna -> artna
</pre><p>

Alternatively, if you prefer to keep your environments clean, you can
do these instead:<p>

<pre>
* NL {T:1}   _ ! anra -> antra
* LN {T:2}   _ ! arna -> artna
* NT 1{2:1}2 _ ! amta -> ampta
* NT 1{1:2}2 _ ! amta -> amnta
</pre><p>

<h3>When all else fails - temporary environments</h3>

Sometimes you just can't get a single rule to do what you want to; in
this case, you'll probably need two or more rules and a bit of
fiddling. For example, say you want to delete a <tt>h</tt> between two
vowels, but not if the first is <tt>a</tt> and the second
<tt>u</tt>. With a single rule, this is almost impossible. Instead,
you can set up a temporary environment with an otherwise unused
character:<p>

<pre>
* 0  ; Vh_V B ! tentatively mark each 'h'; note the banana flag
* ;  0 ah_u   ! remove the marker if necessary
* h; 0 _      ! and get rid of the remaining 'h's.
</pre><p>

Quite often, you'll need a rule which removes stray characters after
this kind of thing:<p>

<pre>* ; 0 _ </pre>

<a name="hlp"></a><hr><h2>Higher-level processing</h2>

SCA has a number of ways to consider rules as more than just isolated
items in a sequence. The principal mechanisms for this are
<b>directives</b> and <b>comments</b>.

<h3>Comments</h3>

Actually, comments don't do anything; they're merely a way for you to
annotate your files without interfering with SCA.<p>

A comment may be specified in two ways. We've already seen the
exclamation mark, which turns everything after itself into a comment
if it's not at the start of a line. If you want an entire line to be a
comment, put a hash character at the start. So:<p>

<pre>
* foo bar _ ! this is a comment
# so is this
!but this isn't - it's a directive and will cause an error
! nor is this
* foo bar _ # and nor is this; it looks like an anchor or a flag
</pre>

<h3>Directives</h3>

A line which starts with an exclamation mark is a directive; it's an
instruction to SCA to do something other than define a rule, category,
or whatever. For example:<p>

<ul>
  <li> <tt>!end</tt> tells SCA not to read any more input. This takes
       precedence over aanything else.
  <li> <tt>!skip</tt> tells SCA to ignore all further input lines
       until further notice.
  <li> <tt>!noskip</tt> undoes all preceding <tt>!skip</tt>s, which do
       not nest.
</ul><p>

These are provided for convenience and not as part of a
<b>cpp</b>-like preprocessor; I really hope nobody's files get that
complicated anyway.<p>

Mnay directives take parameters, which are given as
<tt>!param=value</tt>; some parameters have no value and are given as
just <b>param</b>. For example:<p>

<ul>
  <li> <tt>!include file=FILE</tt> will read in the contents of
       <tt>FILE</tt> before proceeding with the current file. You will
       be warned about recursive includes, so don't try it.
</ul><p>

Other directives will be introduced as appropriate.<p>

You can specify that the value of a parameter may be <a
href="#def">supplied on the command-line</a> (q.v.). Two directives
which can only work this way are:<p>

<ul>
  <li> <tt>!skipif COND</tt>: like <tt>!skip</tt>, but only if
  <tt>COND</tt> is defined on the command-line with <tt>-DCOND</tt>
  <li> <tt>!skipunless COND</tt>: similarly, but only if it is not
  defined.
</ul><p>

<h3>Groups and randomisation</h3>

Rules can be <b>grouped</b> into larger entities with the
<tt>!group</tt> directive; <tt>!endgroup</tt> signals the end of the
group. By itself this isn't very useful, but with the appropriate
parameters you can add a bit of non-determinism to your processing:<p>

<ul>
  <li> <tt>times=N</tt> will execute the group exactly <tt>N</tt> times.
  <li> <tt>shuffle</tt> will randomly reorder the rules in the group before
       applying them, once per iteration.
  <li> <tt>max=N</tt> will process the first <tt>N</tt> rules in the
       group; this is useful in conjunction with <tt>shuffle</tt>.
  <li> <tt>pick=N</tt> is equivalent to <tt>shuffle max=N</tt>, and
       will apply <tt>N</tt> random rules out of the group.
  <li> <tt>prob=N</tt> will execute the entire group only if a random
       number between 0 and 100 is less than <tt>N</tt>.
  <li> <tt>ruleprob=N</tt> is similar, but the probability applies to
       each individual rule within the group.
  <li> <tt>reduce=N</tt> can be used to decrease the values of
       <tt>prob</tt> and <tt>ruleprob</tt> after each iteration; for
       example, <tt>reduce=50</tt> will halve them each time.
  <li> <tt>seed=string</tt> will seed the random numbers with
       <tt>string</tt>. If <tt>string</tt> equals <tt>time</tt>, the
       system clock will be used instead, which should ensure that the
       random numbers are unpredictable. If <tt>string</tt> is
       <tt>word</tt>, the default settings are used (see below).
</ul><p>

You can apply random probabilities to individual rules by expressing
the probability as a percentage flag:<p>

<pre>* x 0 _ 50 ! get rid of the x's half of the time</pre><p>

And you can select random values from categories:<p>

<pre>* x &lt;@vowel&gt; _ ! change x's to random vowels</pre><p>

By default, the random numbers are seeded each time with the next word
to be processed, or with the recently-processed word for the
group-based parameters. This effectively means that rules with
percentages will affect the some words each time, which is hopefully a
good simuation of incomplete sound change.

<h4>Persistence</h4>

A special group consists of the <b>persistent</b> rules, which are
specified with the <tt>P</tt> flag. These rules are all applied, in
the order in which they are defined, after each non-persistent rule;
for example:

<pre>* x 0 _ P ! ensure that we never have any x's</pre><p>

<h3>Dialects</h3>

A <b>dialect</b> is a path through the sequence of rules. Its name
derives, of course, from SCA's original application in simulating
historical linguistic development.<p>

Dialects are identified by single letters or digits; by default you
get the one dialect <tt>A</tt>. All dialects to which your file
applies must be specified at the top of the file with the
<tt>!dialect</tt> directive; thus <tt>!dialect AB C D</tt> declares
that you have four dialects called <tt>A B C D</tt>. You can then
declare that a rule applies to certain dialects only, thus:<p>

<pre>
A...  ~ai,au~  &lt;+EO&gt;   _   ! dialect 'A' collapses diphthongs
.B..  &lt;ustop&gt;  &lt;vstop&gt; V_V ! dialect 'B' does lenition
..C.  V        &lt;@V&gt;        ! dialect 'C' mangles vowels
</pre><p>

The dots aren't necessary, but are convenient for lining up the text
neatly.<p>

To save you having to type out the same dialect specifier in front of
several lines in succession, you can use the <tt>!dirprefix</tt>
directive. The value of its <tt>dialects</tt> parameter is prepended
to each line:<p>

<pre>
!dirprefix dialects=A
# some rules for dialect 'A'
!dirprefix dialects=B
# some rules for dialect 'B'
!dirprefix dialects=
# now need actual dialect specs again
AB foo bar baz_quux
</pre><p>

<a name="except"></a><h3>Exceptions</h3>

Occasionally you want a rule to ignore a specific word. This is done
in SCA through the mechanism of <b>exceptions</b>, which should not be
confused with the exceptions which programming languages throw when
something goes wrong.<p>

To specify an exception to a rule, you need to do two things: identify
the rule, and say which combinations of dialects and words it doesn't
apply to. For example:<p>

<pre>
!exception rule=FOO words=sanctus dialects=ABC
*  c   0   n_t    _   @FOO
</pre><p>

Here the <tt>@FOO</tt> flag gives the name <tt>FOO</tt> to the rule,
and the <tt>!exception</tt> directive says that in dialects <tt>A B
C</tt> the word <tt>sanctus</tt> wil be left alone.<p>

As well as specifying exceptions in the file, you can put then in a
file of their own called <tt>FILE</tt>, which can be read in with the
<tt>!exceptfile file=FILE</tt> directive. This file must be in the
following format for each combination of rule and dialect:<p>

<pre>
@RULE dialects
words words words
words words
words
</pre><p>

<h3>Referring to previous rules and parts</h3>

If the backquote character <tt>`</tt> appears in <tt>BEFORE</tt>,
<tt>AFTER</tt>, or the environment, the part is taken from the
previous rule:<p>

<pre>
A..  s   z   V_V   ! voicing
.B.  `   h   `     ! lenition
..C  `   t   `     ! rhotacism
</pre><p>

Equivalently, you can name the first rule and refer to it
explicitly:<p>

<pre>
A..  s     z V_V   @FOO
.B.  `@FOO h `@FOO
..C  `@FOO t `@FOO
</pre><p>

You can also name specific changes and environments, and use them later:<p>

<pre>
change lenition     &lt;ustop&gt; &lt;vstop&gt;
env    intervocalic V_V

.B. `lenition `intervocalic
</pre><p>

Note that the first definition here defines both <tt>BEFORE</tt> and
<tt>AFTER</tt>; there isn't a lot of point defining just one.

<h3>Headings</h3>

A heading is a comment which is echoed back to the user if
requested. There are three levels of headings:<p>

<pre>
!heading Top-level processing
!subheading not so important stuff
!subsubheading incidentals
</pre><p>

For displaying headings in the output, see the <tt>-L</tt> <a
href="#clopts" >command-line option</a>.

<a name="assert"></a><h3>Assertions</h3>

<b>Assertions</b> allow you to test whether a rule gives the output
you expect. By default they are ignored; you can tell SCA to take
notice of them with the <tt>-A</tt> <a href="#clopts" >command-line
option</a>.<p>

You can specify an assertion with the <tt>!assert</tt> directive,
which applies to the most recently-defined rule:<p>

<pre>
A t d a_e
!assert dialect=A word=ate result=ade
!assert dialect=B word=rate result=rate
</pre><p>

The parameters are hopefully self-explanatory. If an assertion fails,
i.e. if applying the rule to <tt>word</tt> does not give
<tt>result</tt> in <tt>dialect</tt>, SCA will warn and exit.

<h3>L-systems</h3>

Because SCA does list replacements in parallel, lists are ideal for
implementing the rules of an L-system. Here, for example, is how to
produce ten generations of Lindenmayer's original L-system:<p>

<pre>
list predecessor a,b
list successor   ab,a

!group times=10
L ~predecessor~ ~successor~ _
!endgroup
</pre><p>

No doubt, SCA could also specify a workable implementation of <a
href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">John Horton
Conway's Game of Life</a>. This is left as an exercise for the reader.

<hr><a name="clopts"></a><h2>Command-line options</h2>

We've seen some command-line options already; here's the complete
list. Every argument has a short form, which is a single letter, and a
long form, which is one or more words; the short form is preceded by a
hyphen, and the long one by two:<p>

<ul>
  <li> <tt>-X</tt> or <tt>--option</tt> simply turns option <tt>X</tt>
  on;
  <li> <tt>-Xvalue</tt>, <tt>-X value</tt>, or <tt>--option=value</tt>
  supplies <tt>value</tt> with the option.
</ul><p>

All of the options which SCA understands are specified in the file
<tt>SCAparams.yaml</tt>, so you can change them if you really need
to.<p>

<h3>Miscellaneous options</h3>

<ul>
  <li> <tt>-cFILE</tt> or <tt>--scfile=FILE</tt>: tell SCA which
  sound-change file to use. Note that this option is actually
  mandatory. If <tt>FILE</tt> does not end in <tt>.sca</tt>, this
  suffix will be appended automatically.
  <li> <tt>-xFILE</tt> or <tt>--excfile=FILE</tt>: load <a
  href="#exc">exceptions</a> from <tt>FILE</tt>. This has the same
  effect as the <tt>!exceptfile</tt> directive at the start of the
  sound-change file.
  <li> <tt>-i</tt> or <tt>--showdefs</tt>: show everything which is
  defined and exit.
  <li> <tt>-dDIALECTS</tt> or <tt>--dialects=DIALECTS</tt>: process
  the words through <tt>DIALECTS</tt>. By default, all defined
  dialects are used.
  <li> <tt>-eENC</tt> or <tt>--encoding=ENC</tt>: use encoding
  <tt>ENC</tt> for input and output. The default is <tt>utf-8</tt>.
  <li> <tt>-SSTRING</tt> or <tt>--seed=STRING</tt>: set the random
  number seed to <tt>STRING</tt>; this is the same as the
  <tt>!seed</tt> directive.
  <li> <tt>-A</tt> or <tt>--doassert</tt>: run in <a
  href="#assert">assertion mode</a>. 
</ul>

<a name="def"></a><h3>Definitions</h3>

A <b>definition</b> is a name-value pair which can be passed to SCA
and referred to in the parameter list of a directive. A definition is
specified with <tt>-DNAME=VALUE</tt> or<tt>-define=NAME=VALUE</tt>;
the value may be absent, in which case the equals sign is not needed
and SCA is only interested in whether <tt>NAME</tt> is defined.<p>

You can refer to the definition with <tt>&NAME:DEFAULT</tt>; it is not
wise not to supply a default. For example:<p>

<pre>
!group times=&amp;times:5
... rules ...
!endgroup
</pre><p>

This will process the group five times by default, but you can specify
a different number of iterations with <tt>-Dtimes=42</tt>.

<h3>Output to the screen</h3>

By default, SCA will print its output to the screen preceded by a
banner and some information about how many things are defined. Each
input word is preceded by "&gt;" followed by the outcome in each
dialect on the following lines. The following options affect the style
of this display:<p>

<ul>
  <li> <tt>-q</tt> or <tt>--quiet</tt>: don't show the banner or counts.
  <li> <tt>-v</tt> or <tt>--verbose</tt>: show each rule as it's compiled.
  <li> <tt>-m</tt> or <tt>--minimal</tt>: just show the output words;
  this overrides everything below.
  <li> <tt>-r</tt> or <tt>--rules</tt>: display each rule which
  changes the word as text.
  <li> <tt>-R</tt> or <tt>--regexp</tt>: display each rule which
  changes the word as a regular expression; this is useful to see
  what's happening behind the scenes.
  <li> <tt>-a</tt> or <tt>--all</tt>: when used with <tt>-r</tt> or
  <tt>-R</tt>, shows all rules whether they make a change or not.
  <li> <tt>-C</tt> or <tt>--colour</tt>: add colour to the output;
  this requires an ANSI-compatible terminal.
  <li> <tt>-n</tt> or <tt>--showlines</tt>: show the line number on
  which the rule was defined.
  <li> <tt>-LN</tt> or <tt>--level=N</tt>: when used with <tt>-r</tt> or
  <tt>-R</tt>, displays headings, plus subheadings if <tt>N</tt> is 1
  or greater, and subsubheadings if it is 2 or greater.
</ul><p>

<h3>Input files</h3>

SCA can read words from a file and process them in hopefully useful
ways.<p>

The file is specified with <tt>-lFILE</tt> or <tt>--lexfile=FILE</tt>,
as in Mark R's program. If no other options are given, SCA will split
each line in <tt>FILE</tt> on whitespace and process every one of the
resulting words. The <tt>-FSEP</tt> or <tt>--insep=SEP</tt> option
specifies an alternative separator, such as a comma for <tt>.csv</tt>
files.<p>

If you don't want to process all words on a line, use the
<tt>-fFIELDS</tt> or <tt>--fields=FIELDS</tt> option. Here
<tt>FIELDS</tt> is a comma-separated list of numbers and ranges, for
example <tt>1,3-5</tt> for fields 1 3 4 5, or <tt>2</tt> for just one
field. Note that the numbering starts at zero.<p>

<h4>Test files</h4>

The <tt>-tFILE</tt> or <tt>--testfile=FILE</tt> option is especially
interesting. It expects an input file in a strict format, in which the
first line is treated as a header; one field in the header must
contain the word <tt>in</tt>, and each of the others must specify a
dialect such as <tt>A</tt>; optionally, one field may contain
<tt>out</tt>. On each subsequent line, the word in the field headed
<tt>in</tt> is processed in each of the dialects specified in the
other fields in the header, and the results are compared to the
corresponding fields in the line; all differences are reported, with
the test in the <tt>out</tt> field (if present) output to facilitate
identification.<p>

For example, if you're investigating Romance diachronics, you might
use a test file like this:<p>

<pre>
in     out   P     E     F     I
únus   one   um    uno   un    uno
duó    two   dois  dos   deux  due
trés   three tres  tres  trois tre
</pre>

<h3>Output files</h3>

By default, the output from processing an input file goes to the
screen. There is a little magic built into SCA to send it to a file
instead.<p>

You can specify the output file name with <tt>-oFILE</tt> or
<tt>--outfile=FILE</tt>. By default the output is written in
fixed-width columns of width 15; you can change the width with
<tt>-wN</tt> or <tt>--width=N</tt>, or supply an output separator
<tt>C</tt> with <tt>-sC</tt> or <tt>--sep-C</tt>.<p>

What now happens is that each input line is written to the output, and
for each field specified with <tt>-f</tt> (all fields by default), the
results of processing the word in that field through the specified
dialects are appended to the input line. If you supply the <tt>-H</tt>
or <tt>--header</tt> option, the first line in the input file is
treated as a header and is not processed; the extra columns are
identified with the respective dialects. Obviously, you won't want too
many input words on each line when doing this.

<a name="conv"></a><hr><h2>Converting from older versions</h2>

If you have a <tt>.sc</tt> file from version 0.6 of the older SCA,
you can convert it to a <tt>.sca</tt> file which will work with
version 0.8 with the help of the following.<p>

<h3>Now directives</h3>

The following features should be convered to directives:<p>

<ul>
  <li> <tt>#: #:: #:::</tt> -> <tt>!heading !subheading !subsubheading</tt>
  <li> <tt>SKIP NOSKIP END</tt> -> <tt>!skip !noskip !end</tt>
  <li> <tt>SKIP IF COND</tt> -> <tt>!skipif cond=COND</tt>
  <li> <tt>SKIP UNLESS COND</tt> -> <tt>!skipunless cond=COND</tt>
  <li> <tt>Include = FILE</tt> -> <tt>!include file=FILE</tt>
  <li> <tt>dialects = DIALECTS</tt> -> <tt>!dialects DIALECTS</tt>
  <li> <tt>exceptions = FILE</tt> -> <tt>!exceptfile file=FILE</tt>
  <li> <tt>except = ID WORDS</tt> -> <tt>!exception rule=ID
  dialects=DIALECTS word=WORD</tt>, once for each <tt>WORD</tt> in
  <tt>WORDS</tt> 
  <li> <tt>assert = DIAL WORD RESULT</tt> -> <tt>!assert dialect=DIAL
  word=WORD result=RESULT</tt>
  <li> <tt>conditions</tt> -> now on the command-line with <tt>-D</tt>
</ul><p>

The following are no longer supported:<p>

<ul>
  <li> <tt>``</tt>; use a single <tt>`</tt> in each part instead.
  <li> The <tt>&lt;&lt;cat&gt;&gt;</tt> category specification now needs
       single angle brackets.<p>
</ul><p>

The <tt>%</tt> on the end of a percentage is no longer required, and
will probably cause an error. Similarly, references to individual
items within <tt>BEFORE</tt> no longer need a hash character.<p>

Finally, <a href="#rcm" >mappings</a> are sufficently different to
require individual attention. A mapping like <tt>{1AB}</tt> can
probably be converted to <tt>&lt;1B&gt;</tt>, and those like
<tt>{>}</tt> can hopefullybe left alone, but it's difficult to
generalise otherwise.<p>

<a name="sample"></a><hr><h2>Sample rules</h2>

For fun, here are some rules which implement well-known sound
changes.<p>

<h3>Palatalisation of velars</h3>

For example, in Slavic or Romance.<p>

<pre>
velar   = kgxɣ
palatal = ʧʤʃʒ
front   = iíîeéê
* &lt;velar&gt;j &lt;1palatal&gt; _        ! rakja -> raʧa
* &lt;velar&gt;  &lt;palatal&gt;  _&lt;front&gt; ! raki -> raʧi

* Kj C _  ! very concise alternative
</pre>

<h3>Hungarian-style vowel harmony</h3>

First of all:<p>

<pre>
front = eøy
back  = aou
</pre><p>

If the harmony is dictated by the first vowel in the word:<p>

<pre>
* &lt;front&gt; &lt;back&gt;  &lt;back&gt;.*_  B
* &lt;back&gt;  &lt;front&gt; &lt;front&gt;.*_ B
</pre><p>

If it's dictated by the last vowel in the word, we need a reverse
banana (and you were wondering what the point of that was, weren't
you?):<p>

<pre>
* &lt;front&gt; &lt;back&gt;  _.*&lt;back&gt;  R
* &lt;back&gt;  &lt;front&gt; _.*&lt;front&gt; R
</pre><p>

<h3>i-umlaut</h3>

Using the categories previously defined:<p>

<pre>&lt;back&gt;   &lt;front&gt;   _&lt;cons&gt;+&lt;+jiíî&gt;</pre><p>

<h3>Sievers' Law</h3>

This causes front vowels to appear before glides which follow heavy
syllables:<p>

<pre>
C  = (consonants)
G  = wj
hi = ui
V  = (all vowels)
Ά  = (long vowels)

* CG 1{2hi}2   #|C|Ά|VV|h_V B 
</pre><p>

See if you can work out why you can't use zero in <tt>BEFORE</tt> here.

<hr></body></html>
